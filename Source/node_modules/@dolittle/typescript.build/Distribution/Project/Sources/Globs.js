"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
*  Copyright (c) Dolittle. All rights reserved.
*  Licensed under the MIT License. See LICENSE in the project root for license information.
*--------------------------------------------------------------------------------------------*/
const slash_1 = __importDefault(require("slash"));
const is_glob_1 = __importDefault(require("is-glob"));
/**
 * Returns a glob pattern as a glob pattern with absolute path instead of relative.
 *
 * @export
 * @param {string} rootFolder The root folder where the the relative glob is supposed to be used from
 * @param {string} glob The relative glob pattern
 * @returns
 */
function globAsAbsoluteGlob(rootFolder, glob) {
    return `${slash_1.default(rootFolder)}/${glob}`;
}
exports.globAsAbsoluteGlob = globAsAbsoluteGlob;
/**
 * Transforms a pattern into multiple patterns for avoiding files under node_modules
 *
 * @export
 * @param {string} pattern
 * @returns
 */
function toPatternsThatIgnoreNodeModules(pattern) {
    return [
        pattern,
        `**/!(node_modules)/**/${pattern}`,
        `**/!(node_modules)/${pattern}`
    ];
}
exports.toPatternsThatIgnoreNodeModules = toPatternsThatIgnoreNodeModules;
/**
 * Creates glob patterns for matching one or more file extensions
 *
 * @export
 * @param {string[]} fileExtensions
 * @returns
 */
function asPossibleFileExtensionsPattern(fileExtensions, negate = false) {
    if (fileExtensions.length <= 0)
        throw new Error('No file extension to create pattern from');
    return `.${negate === true ? '!' : '@'}(${fileExtensions.join('|')})`;
}
exports.asPossibleFileExtensionsPattern = asPossibleFileExtensionsPattern;
/**
 * Creates glob patterns
 *
 * @export
 * @param {string} rootFolderAbsolutePath
 * @param {string[]} globPatterns
 * @param {string} [folderName] The name of the folder where the files live under. Used for the relative glob pattern
 * @returns
 */
function createGlobPatterns(rootFolderAbsolutePath, globPatterns, folderName) {
    const result = [];
    globPatterns.forEach(globPattern => {
        if (!is_glob_1.default(globPattern))
            throw new Error(`'${globPattern}' is not a valid glob pattern`);
        result.push({ relative: `${folderName ? `${folderName}/` : ''}${globPattern}`, absolute: globAsAbsoluteGlob(rootFolderAbsolutePath, globPattern) });
    });
    return result;
}
exports.createGlobPatterns = createGlobPatterns;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2xvYnMuanMiLCJzb3VyY2VSb290IjoiLi9Tb3VyY2UvIiwic291cmNlcyI6WyJQcm9qZWN0L1NvdXJjZXMvR2xvYnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7OytGQUcrRjtBQUMvRixrREFBK0I7QUFDL0Isc0RBQTZCO0FBNEI3Qjs7Ozs7OztHQU9HO0FBQ0gsU0FBZ0Isa0JBQWtCLENBQUMsVUFBa0IsRUFBRSxJQUFZO0lBQy9ELE9BQU8sR0FBRyxlQUFVLENBQUMsVUFBVSxDQUFDLElBQUksSUFBSSxFQUFFLENBQUM7QUFDL0MsQ0FBQztBQUZELGdEQUVDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsU0FBZ0IsK0JBQStCLENBQUMsT0FBZTtJQUMzRCxPQUFPO1FBQ0gsT0FBTztRQUNQLHlCQUF5QixPQUFPLEVBQUU7UUFDbEMsc0JBQXNCLE9BQU8sRUFBRTtLQUNsQyxDQUFDO0FBQ04sQ0FBQztBQU5ELDBFQU1DO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsU0FBZ0IsK0JBQStCLENBQUMsY0FBd0IsRUFBRSxTQUFrQixLQUFLO0lBQzdGLElBQUksY0FBYyxDQUFDLE1BQU0sSUFBSSxDQUFDO1FBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQywwQ0FBMEMsQ0FBQyxDQUFDO0lBQzVGLE9BQU8sSUFBSSxNQUFNLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxjQUFjLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7QUFDMUUsQ0FBQztBQUhELDBFQUdDO0FBRUQ7Ozs7Ozs7O0dBUUc7QUFDSCxTQUFnQixrQkFBa0IsQ0FBQyxzQkFBOEIsRUFBRSxZQUFzQixFQUFFLFVBQW1CO0lBQzFHLE1BQU0sTUFBTSxHQUFrQixFQUFFLENBQUM7SUFDakMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsRUFBRTtRQUMvQixJQUFJLENBQUMsaUJBQU0sQ0FBQyxXQUFXLENBQUM7WUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLElBQUksV0FBVywrQkFBK0IsQ0FBQyxDQUFDO1FBQzFGLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBQyxRQUFRLEVBQUUsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxXQUFXLEVBQUUsRUFBRSxRQUFRLEVBQUUsa0JBQWtCLENBQUMsc0JBQXNCLEVBQUUsV0FBVyxDQUFDLEVBQUMsQ0FBQyxDQUFDO0lBQ3RKLENBQUMsQ0FBQyxDQUFDO0lBQ0gsT0FBTyxNQUFNLENBQUM7QUFDbEIsQ0FBQztBQVBELGdEQU9DIiwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogIENvcHlyaWdodCAoYykgRG9saXR0bGUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMSUNFTlNFIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHRvVW5peFBhdGggZnJvbSAnc2xhc2gnO1xuaW1wb3J0IGlzR2xvYiBmcm9tICdpcy1nbG9iJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgZ2xvYiBwYXR0ZXJuIGluIGJvdGggcmVsYXRpdmUgYW5kIGFic29sdXRlIGZvcm1cbiAqL1xuZXhwb3J0IHR5cGUgR2xvYlBhdHRlcm4gPSB7XG4gICAgLyoqXG4gICAgICogQSByZWxhdGl2ZSBwYXR0ZXJuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHJlbGF0aXZlOiBzdHJpbmcsXG5cbiAgICAvKipcbiAgICAgKiBBbiBhYnNvbHV0ZSBwYXR0ZXJuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGFic29sdXRlOiBzdHJpbmdcbn07XG5cbi8qKlxuICogUmVwcmVzZW50cyBnbG9iIHBhdHRlcm5zXG4gKi9cbmV4cG9ydCB0eXBlIEdsb2JzID0ge1xuICAgIGluY2x1ZGVzOiBHbG9iUGF0dGVybltdLFxuICAgIGV4Y2x1ZGVzOiBHbG9iUGF0dGVybltdO1xufTtcbi8qKlxuICogUmV0dXJucyBhIGdsb2IgcGF0dGVybiBhcyBhIGdsb2IgcGF0dGVybiB3aXRoIGFic29sdXRlIHBhdGggaW5zdGVhZCBvZiByZWxhdGl2ZS5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vdEZvbGRlciBUaGUgcm9vdCBmb2xkZXIgd2hlcmUgdGhlIHRoZSByZWxhdGl2ZSBnbG9iIGlzIHN1cHBvc2VkIHRvIGJlIHVzZWQgZnJvbVxuICogQHBhcmFtIHtzdHJpbmd9IGdsb2IgVGhlIHJlbGF0aXZlIGdsb2IgcGF0dGVyblxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdsb2JBc0Fic29sdXRlR2xvYihyb290Rm9sZGVyOiBzdHJpbmcsIGdsb2I6IHN0cmluZykge1xuICAgIHJldHVybiBgJHt0b1VuaXhQYXRoKHJvb3RGb2xkZXIpfS8ke2dsb2J9YDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGEgcGF0dGVybiBpbnRvIG11bHRpcGxlIHBhdHRlcm5zIGZvciBhdm9pZGluZyBmaWxlcyB1bmRlciBub2RlX21vZHVsZXNcbiAqXG4gKiBAZXhwb3J0XG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVyblxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUGF0dGVybnNUaGF0SWdub3JlTm9kZU1vZHVsZXMocGF0dGVybjogc3RyaW5nKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgcGF0dGVybixcbiAgICAgICAgYCoqLyEobm9kZV9tb2R1bGVzKS8qKi8ke3BhdHRlcm59YCxcbiAgICAgICAgYCoqLyEobm9kZV9tb2R1bGVzKS8ke3BhdHRlcm59YFxuICAgIF07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBnbG9iIHBhdHRlcm5zIGZvciBtYXRjaGluZyBvbmUgb3IgbW9yZSBmaWxlIGV4dGVuc2lvbnNcbiAqXG4gKiBAZXhwb3J0XG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWxlRXh0ZW5zaW9uc1xuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzUG9zc2libGVGaWxlRXh0ZW5zaW9uc1BhdHRlcm4oZmlsZUV4dGVuc2lvbnM6IHN0cmluZ1tdLCBuZWdhdGU6IGJvb2xlYW4gPSBmYWxzZSkge1xuICAgIGlmIChmaWxlRXh0ZW5zaW9ucy5sZW5ndGggPD0gMCkgdGhyb3cgbmV3IEVycm9yKCdObyBmaWxlIGV4dGVuc2lvbiB0byBjcmVhdGUgcGF0dGVybiBmcm9tJyk7XG4gICAgcmV0dXJuIGAuJHtuZWdhdGUgPT09IHRydWUgPyAnIScgOiAnQCd9KCR7ZmlsZUV4dGVuc2lvbnMuam9pbignfCcpfSlgO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgZ2xvYiBwYXR0ZXJuc1xuICpcbiAqIEBleHBvcnRcbiAqIEBwYXJhbSB7c3RyaW5nfSByb290Rm9sZGVyQWJzb2x1dGVQYXRoXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBnbG9iUGF0dGVybnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZm9sZGVyTmFtZV0gVGhlIG5hbWUgb2YgdGhlIGZvbGRlciB3aGVyZSB0aGUgZmlsZXMgbGl2ZSB1bmRlci4gVXNlZCBmb3IgdGhlIHJlbGF0aXZlIGdsb2IgcGF0dGVyblxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUdsb2JQYXR0ZXJucyhyb290Rm9sZGVyQWJzb2x1dGVQYXRoOiBzdHJpbmcsIGdsb2JQYXR0ZXJuczogc3RyaW5nW10sIGZvbGRlck5hbWU/OiBzdHJpbmcpIHtcbiAgICBjb25zdCByZXN1bHQ6IEdsb2JQYXR0ZXJuW10gPSBbXTtcbiAgICBnbG9iUGF0dGVybnMuZm9yRWFjaChnbG9iUGF0dGVybiA9PiB7XG4gICAgICAgIGlmICghaXNHbG9iKGdsb2JQYXR0ZXJuKSkgdGhyb3cgbmV3IEVycm9yKGAnJHtnbG9iUGF0dGVybn0nIGlzIG5vdCBhIHZhbGlkIGdsb2IgcGF0dGVybmApO1xuICAgICAgICByZXN1bHQucHVzaCh7cmVsYXRpdmU6IGAke2ZvbGRlck5hbWUgPyBgJHtmb2xkZXJOYW1lfS9gIDogJyd9JHtnbG9iUGF0dGVybn1gLCBhYnNvbHV0ZTogZ2xvYkFzQWJzb2x1dGVHbG9iKHJvb3RGb2xkZXJBYnNvbHV0ZVBhdGgsIGdsb2JQYXR0ZXJuKX0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4iXX0=