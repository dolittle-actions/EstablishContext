{"version":3,"file":"Transformations.js","sourceRoot":"","sources":["../../src/Transformations.ts"],"names":[],"mappings":"","sourcesContent":["import { AllArguments } from \"./Arguments\";\r\n\r\ntype FunctionSubstituteWithOverloads<TFunc, Terminating = false> =\r\n    TFunc extends {\r\n        (...args: infer A1): infer R1;\r\n        (...args: infer A2): infer R2;\r\n        (...args: infer A3): infer R3;\r\n        (...args: infer A4): infer R4;\r\n        (...args: infer A5): infer R5;\r\n    } ?\r\n    FunctionHandler<A1, R1, Terminating> & FunctionHandler<A2, R2, Terminating> &\r\n    FunctionHandler<A3, R3, Terminating> & FunctionHandler<A4, R4, Terminating>\r\n    & FunctionHandler<A5, R5, Terminating> : TFunc extends {\r\n        (...args: infer A1): infer R1;\r\n        (...args: infer A2): infer R2;\r\n        (...args: infer A3): infer R3;\r\n        (...args: infer A4): infer R4;\r\n    } ?\r\n    FunctionHandler<A1, R1, Terminating> & FunctionHandler<A2, R2, Terminating> &\r\n    FunctionHandler<A3, R3, Terminating> & FunctionHandler<A4, R4, Terminating> : TFunc extends {\r\n        (...args: infer A1): infer R1;\r\n        (...args: infer A2): infer R2;\r\n        (...args: infer A3): infer R3;\r\n    } ?\r\n    FunctionHandler<A1, R1, Terminating> & FunctionHandler<A2, R2, Terminating>\r\n    & FunctionHandler<A3, R3, Terminating> : TFunc extends {\r\n        (...args: infer A1): infer R1;\r\n        (...args: infer A2): infer R2;\r\n    } ?\r\n    FunctionHandler<A1, R1, Terminating> & FunctionHandler<A2, R2, Terminating> : TFunc extends {\r\n        (...args: infer A1): infer R1;\r\n    } ?\r\n    FunctionHandler<A1, R1, Terminating> : never;\r\n\r\ntype Equals<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? true : false;\r\ntype FunctionHandler<TArguments extends any[], TReturnType, Terminating> =\r\n    Equals<TArguments, unknown[]> extends true ?\r\n    {} : Terminating extends true ?\r\n    TerminatingFunction<TArguments> :\r\n    FunctionSubstitute<TArguments, TReturnType>\r\n\r\nexport type FunctionSubstitute<TArguments extends any[], TReturnType> =\r\n    ((...args: TArguments) => (TReturnType & MockObjectMixin<TArguments, TReturnType>)) &\r\n    ((allArguments: AllArguments<TArguments>) => (TReturnType & MockObjectMixin<TArguments, TReturnType>))\r\n\r\nexport type NoArgumentFunctionSubstitute<TReturnType> = (() => (TReturnType & NoArgumentMockObjectMixin<TReturnType>))\r\nexport type PropertySubstitute<TReturnType> = (TReturnType & Partial<NoArgumentMockObjectMixin<TReturnType>>);\r\n\r\ntype OneArgumentRequiredFunction<TArgs, TReturnType> = (requiredInput: TArgs, ...restInputs: TArgs[]) => TReturnType;\r\n\r\ntype MockObjectPromise<TReturnType> = TReturnType extends Promise<infer U> ? {\r\n    resolves: OneArgumentRequiredFunction<U, void>;\r\n    rejects: OneArgumentRequiredFunction<any, void>;\r\n} : {}\r\n\r\ntype BaseMockObjectMixin<TReturnType> = MockObjectPromise<TReturnType> & {\r\n    returns: OneArgumentRequiredFunction<TReturnType, void>;\r\n    throws: OneArgumentRequiredFunction<any, never>;\r\n}\r\n\r\ntype NoArgumentMockObjectMixin<TReturnType> = BaseMockObjectMixin<TReturnType> & {\r\n    mimicks: OneArgumentRequiredFunction<() => TReturnType, void>;\r\n}\r\n\r\ntype MockObjectMixin<TArguments extends any[], TReturnType> = BaseMockObjectMixin<TReturnType> & {\r\n    mimicks: OneArgumentRequiredFunction<(...args: TArguments) => TReturnType, void>;\r\n}\r\n\r\nexport type ObjectSubstitute<T extends Object, K extends Object = T> = ObjectSubstituteTransformation<T> & {\r\n    received(amount?: number): TerminatingObject<K>;\r\n    didNotReceive(): TerminatingObject<K>;\r\n    mimick(instance: T): void;\r\n}\r\n\r\ntype TerminatingFunction<TArguments extends any[]> = ((...args: TArguments) => void) & ((arg: AllArguments<TArguments>) => void)\r\n\r\ntype TerminatingObject<T> = {\r\n    [P in keyof T]:\r\n    T[P] extends (...args: infer F) => any ?\r\n    F extends [] ? () => void :\r\n    FunctionSubstituteWithOverloads<T[P], true> :\r\n    T[P];\r\n}\r\n\r\ntype ObjectSubstituteTransformation<T extends Object> = {\r\n    [P in keyof T]:\r\n    T[P] extends (...args: infer F) => infer R ?\r\n    F extends [] ? NoArgumentFunctionSubstitute<R> :\r\n    FunctionSubstituteWithOverloads<T[P]> :\r\n    PropertySubstitute<T[P]>;\r\n}\r\n\r\ntype Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;\r\n\r\nexport type OmitProxyMethods<T extends any> = Omit<T, 'mimick' | 'received' | 'didNotReceive'>;\r\nexport type DisabledSubstituteObject<T> = T extends ObjectSubstitute<OmitProxyMethods<infer K>, infer K> ? K : never;\r\n"]}