{"version":3,"file":"Arguments.js","sourceRoot":"","sources":["../../src/Arguments.ts"],"names":[],"mappings":";;;AAIA,MAAM,YAAY;IACd,YACY,YAAoB,EACpB,iBAAuC,EACvC,QAA0B;QAF1B,iBAAY,GAAZ,YAAY,CAAQ;QACpB,sBAAiB,GAAjB,iBAAiB,CAAsB;QACvC,aAAQ,GAAR,QAAQ,CAAkB;IAClC,CAAC;IAEL,OAAO,CAAC,GAAM;;QACV,MAAM,YAAY,eAAG,IAAI,CAAC,QAAQ,0CAAE,YAAY,mCAAI,KAAK,CAAA;QACzD,OAAO,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC;IACrF,CAAC;IAED,QAAQ;QACJ,OAAO,IAAI,CAAC,YAAY,CAAC;IAC7B,CAAC;IAED,CAAC,MAAM,CAAC,GAAG,CAAC,4BAA4B,CAAC,CAAC;QACtC,OAAO,IAAI,CAAC,YAAY,CAAC;IAC7B,CAAC;CACJ;AAED,MAAa,QAAY,SAAQ,YAAe;IAE5C,YAAY,WAAmB,EAAE,gBAAsC,EAAE,OAAyB;QAC9F,KAAK,CAAC,WAAW,EAAE,gBAAgB,EAAE,OAAO,CAAC,CAAC;QAFjC,UAAK,GAAG,gBAAgB,CAAC;IAG1C,CAAC;IACD,IAAI,IAAI;QACJ,OAAO,IAAI,CAAC,KAAK,CAAC;IACtB,CAAC;CACJ;AARD,4BAQC;AAED,MAAa,YAA8B,SAAQ,YAAe;IAE9D;QACI,KAAK,CAAC,OAAO,EAAE,GAAG,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;QAFlB,UAAK,GAAG,cAAc,CAAC;IAGxC,CAAC;IACD,IAAI,IAAI;QACJ,OAAO,IAAI,CAAC,KAAK,CAAC;IACtB,CAAC;CACJ;AARD,oCAQC;AAED,IAAiB,GAAG,CA2DnB;AA3DD,WAAiB,GAAG;IAIhB,MAAM,OAAO,GAAG,CAAC,QAAkB,EAAE,EAAE,CAAC,CAAI,GAAG,IAAW,EAAK,EAAE,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,CAAA;IACnF,MAAM,WAAW,GAAG,CAAC,GAAQ,EAAE,EAAE;QAC7B,IAAI,OAAO,GAAG,CAAC,OAAO,KAAK,UAAU;YACjC,OAAO,GAAG,CAAC,OAAO,EAAE,CAAC;QAEzB,IAAI,OAAO,GAAG,CAAC,QAAQ,KAAK,UAAU;YAClC,OAAO,GAAG,CAAC,QAAQ,EAAE,CAAC;QAE1B,OAAO,GAAG,CAAC;IACf,CAAC,CAAA;IAEY,OAAG,GAAG,GAAqC,EAAE,CAAC,IAAI,YAAY,EAAK,CAAC;IAGjF,MAAM,UAAU,GAAG,CAAiC,SAAY,EAAE,OAAyB,EAAE,EAAE,CAAC,IAAI,QAAQ,CACxG,cAAc,WAAW,CAAC,SAAS,CAAC,GAAG,EAAE,SAAS,EAAE,OAAO,CAC9D,CAAC;IAEF,MAAM,aAAa,GAAmB,CAAC,SAAS,EAAE,EAAE,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,SAAS,CAAC,CAAC;IACpF,aAAa,CAAC,GAAG,GAAG,CAAC,SAAS,EAAE,EAAE,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,SAAS,EAAE,EAAE,YAAY,EAAE,IAAI,EAAE,CAAC,CAAC;IAC7E,MAAE,GAAG,aAAa,CAAA;IAgB/B,MAAM,WAAW,GAAG,CAAC,OAAgB,KAAK,EAAE,OAAyB,EAAE,EAAE;QACrE,MAAM,WAAW,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,SAAS,IAAI,GAAG,CAAC;QAC3D,MAAM,SAAS,GAAG,CAAC,CAAM,EAAE,EAAE;YACzB,QAAQ,IAAI,EAAE;gBACV,KAAK,KAAK;oBACN,OAAO,IAAI,CAAC;gBAChB,KAAK,OAAO;oBACR,OAAO,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;gBAC5B;oBACI,OAAO,OAAO,CAAC,KAAK,IAAI,CAAC;aAChC;QACL,CAAC,CAAA;QAED,OAAO,IAAI,QAAQ,CAAC,WAAW,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;IACzD,CAAC,CAAA;IAED,MAAM,cAAc,GAAoB,CAAC,IAAI,EAAE,EAAE,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,CAAC;IAC7E,cAAc,CAAC,GAAG,GAAG,CAAC,IAAI,EAAE,EAAE,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,IAAI,EAAE,EAAE,YAAY,EAAE,IAAI,EAAE,CAAC,CAAC;IACrE,OAAG,GAAG,cAAc,CAAC;AACtC,CAAC,EA3DgB,GAAG,GAAH,WAAG,KAAH,WAAG,QA2DnB","sourcesContent":["type PredicateFunction<T> = (arg: T) => boolean\r\ntype ArgumentOptions = {\r\n    inverseMatch?: boolean\r\n}\r\nclass BaseArgument<T> {\r\n    constructor(\r\n        private _description: string,\r\n        private _matchingFunction: PredicateFunction<T>,\r\n        private _options?: ArgumentOptions\r\n    ) { }\r\n\r\n    matches(arg: T) {\r\n        const inverseMatch = this._options?.inverseMatch ?? false\r\n        return inverseMatch ? !this._matchingFunction(arg) : this._matchingFunction(arg);\r\n    }\r\n\r\n    toString() {\r\n        return this._description;\r\n    }\r\n\r\n    [Symbol.for('nodejs.util.inspect.custom')]() {\r\n        return this._description;\r\n    }\r\n}\r\n\r\nexport class Argument<T> extends BaseArgument<T> {\r\n    private readonly _type = 'SingleArgument';\r\n    constructor(description: string, matchingFunction: PredicateFunction<T>, options?: ArgumentOptions) {\r\n        super(description, matchingFunction, options);\r\n    }\r\n    get type(): 'SingleArgument' {\r\n        return this._type;\r\n    }\r\n}\r\n\r\nexport class AllArguments<T extends any[]> extends BaseArgument<T> {\r\n    private readonly _type = 'AllArguments';\r\n    constructor() {\r\n        super('{all}', () => true, {});\r\n    }\r\n    get type(): 'AllArguments' {\r\n        return this._type;\r\n    }\r\n}\r\n\r\nexport namespace Arg {\r\n    type ExtractFirstArg<T> = T extends AllArguments<infer TArgs> ? TArgs[0] : T\r\n    type ReturnArg<T> = Argument<T> & T;\r\n    type Inversable<T> = T & { not: T }\r\n    const factory = (factoryF: Function) => <T>(...args: any[]): T => factoryF(...args)\r\n    const toStringify = (obj: any) => {\r\n        if (typeof obj.inspect === 'function')\r\n            return obj.inspect();\r\n\r\n        if (typeof obj.toString === 'function')\r\n            return obj.toString();\r\n\r\n        return obj;\r\n    }\r\n\r\n    export const all = <T extends any[]>(): AllArguments<T> => new AllArguments<T>();\r\n\r\n    type Is = <T>(predicate: PredicateFunction<ExtractFirstArg<T>>) => ReturnArg<ExtractFirstArg<T>>\r\n    const isFunction = <T extends PredicateFunction<T>>(predicate: T, options?: ArgumentOptions) => new Argument(\r\n        `{predicate ${toStringify(predicate)}}`, predicate, options\r\n    );\r\n\r\n    const isArgFunction: Inversable<Is> = (predicate) => factory(isFunction)(predicate);\r\n    isArgFunction.not = (predicate) => factory(isFunction)(predicate, { inverseMatch: true });\r\n    export const is = isArgFunction\r\n\r\n    type MapAnyReturn<T> = T extends 'any' ?\r\n        ReturnArg<any> : T extends 'string' ?\r\n        ReturnArg<string> : T extends 'number' ?\r\n        ReturnArg<number> : T extends 'boolean' ?\r\n        ReturnArg<boolean> : T extends 'symbol' ?\r\n        ReturnArg<symbol> : T extends 'undefined' ?\r\n        ReturnArg<undefined> : T extends 'object' ?\r\n        ReturnArg<object> : T extends 'function' ?\r\n        ReturnArg<Function> : T extends 'array' ?\r\n        ReturnArg<any[]> : any;\r\n\r\n    type AnyType = 'string' | 'number' | 'boolean' | 'symbol' | 'undefined' | 'object' | 'function' | 'array' | 'any';\r\n    type Any = <T extends AnyType = 'any'>(type?: T) => MapAnyReturn<T>;\r\n\r\n    const anyFunction = (type: AnyType = 'any', options?: ArgumentOptions) => {\r\n        const description = !type ? '{any arg}' : `{type ${type}}`;\r\n        const predicate = (x: any) => {\r\n            switch (type) {\r\n                case 'any':\r\n                    return true;\r\n                case 'array':\r\n                    return Array.isArray(x);\r\n                default:\r\n                    return typeof x === type;\r\n            }\r\n        }\r\n\r\n        return new Argument(description, predicate, options);\r\n    }\r\n\r\n    const anyArgFunction: Inversable<Any> = (type) => factory(anyFunction)(type);\r\n    anyArgFunction.not = (type) => factory(anyFunction)(type, { inverseMatch: true });\r\n    export const any = anyArgFunction;\r\n}"]}